<html>

<head>
<meta http-equiv="Content-Language" content="fr">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta name="keywords" lang="fr" content="Ciel profond Enregistrement Empilement Astrophotographie Bayer matrice">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>DeepSkyStacker - Détails Techniques</title>
<style>
<!--
.Standard    { text-align: justify; margin-left: 5; margin-right: 10 }
-->
</style>
</head>

<body>

<p><b><font face="Arial" size="5">Détails techniques</font></b></p>
<blockquote>

<p><b><font face="Arial"><a href="#Registering">Enregistrement</a><br>
<a href="#Alignment">Alignement</a><br>
<a href="#filegroup">Les groupes de fichiers</a><br>
<a href="#Stacking">Empilement</a><br>
<a href="#stackingmethods">Les méthodes d'empilement</a><br>
<a href="#Drizzle">Drizzle</a><br>
<a href="#cometstacking">Empilement d'images de comète</a><br>
<a href="#rawdecod">Décodage et traitement des fichiers RAW</a></font></b></p>
</blockquote>
<hr color="#0000FF">
<p align="justify"><font face="Arial"><b><font color="#FF0000" size="4">
<a name="Registering"></a>Enregistrement</font><font size="2"><br>
Détection des étoiles</font><br>
</b><font size="2">Pour chaque image, DeepSkyStacker détecte automatiquement les 
étoiles.<br>
Sans rentrer dans les détails, une étoile  est un objet rond 
dont la luminosité va décroissante de façon régulière dans toutes les 
directions..<br>
Une fois l'étoile détectée, son centre exact est calculé à l'aide d'une courbe 
de Gauss sur la luminosité.</font></font></p>
<hr color="#0000FF" size="1">
<p align="justify"><font face="Arial"><b><font size="2">Utilisation des darks, flat et offsets 
pendant l'enregistrement</font><br>
</b><font size="2">Si des darks, flat et offsets sont cochés ils sont 
automatiquement appliqués aux images avant l'enregistrement..<br>
Dans le cas d'images comportant de nombreux pixels chauds il est fortement 
conseillés de sélectionner au moins des fichiers darks pour éviter de fausse 
détection d'étoiles..</font></font></p>
<hr color="#0000FF" size="1">
<p align="justify"><font face="Arial"><b>
<font size="2"><a name="hotpixels"></a>Détection automatique des pixels chauds</font><br>
</b><font size="2">Optionnellement DeepSkyStacker tente de détecter les pixels 
chauds pendant le processus d'enregistrement afin des les éliminer pour ne pas 
les confondre avec des étoiles.<br>
Il faut noter que cette option n'est valable que sur les images monochromes et 
sur les images RAW ou FITS dans les modes <a href="#superpixel">Super-pixels</a>,
<a href="#bayerdrizzle">Bayer.Drizzle</a> et interpolation bilinéaire ou AHD.</font></font></p>
<hr color="#0000FF" size="1">
<p align="justify"><b><font face="Arial" size="2"><a name="detectionthreshold"></a>Changement du 
seuil de détection des étoiles</font></b><font size="2" face="Arial"><b><br>
</b>Le seuil de détection des étoiles est fixé à 10% par défaut (10% de la 
luminosité maximale).<br>
Vous pouvez modifier ce seuil dans l'onglet Avancé des paramètres 
d'enregistrement. En baissant le seuil DeepSkyStacker détectera des étoiles plus 
faibles et en l'augmentant uniquement les étoiles plus brillantes seront 
détectées.<br>
<br>
Afin de vous aider à définir au mieux ce seuil il est possible de calculer le 
nombre d'étoiles a priori détectées. Pour ce faire DeepSkyStacker utilise la 
première image cochée, et active temporairement la détection automatique des 
pixels chauds.<br>
<br>
Il faut noter que ce nombre n'est qu'une indication et que le nombre réel 
d'étoiles détectées peut varier en particulier si des images darks, offsets et 
flat sont cochées.</font></p>
<hr color="#0000FF" size="1">
<p align="justify"><font size="2" face="Arial"><b>Sauvegarde des résultats de l'enregistrement<br>
</b>Les paramètres de l'enregistrement (nombre d'étoiles détectées, position, 
luminosité de chaque étoile) sont sauvegardés dans un fichier texte qui porte le 
même nom que l'image avec l'extension .Info.txt.<br>
Ceci évite de procéder de nouveau à l'enregistrement lors d'un futur processus 
d'empilement..</font></p>
<hr color="#0000FF" size="1">
<p align="justify"><font size="2" face="Arial"><b>Résultats de l'enregistrement et paramètres<br>
</b>Le résultat de l'enregistrement est étroitement dépendant des paramètres 
sélectionnés (en particulier  des paramètres de 
développement des fichiers raw).<br>
En cas de modification de ces paramètres, il est impératif de procéder de 
nouveau à l'enregistrement des images.
</font></p>
<hr color="#0000FF" size="1">
<p align="justify"><font size="2" face="Arial"><b>Empilement après enregistrement<br>
</b>DeepSkyStacker permet d'enchaîner automatiquement l'enregistrement et 
l'empilement des images. Il suffit juste de préciser le pourcentage des images 
qui seront conservées à l'issu du processus d'enregistrement pour l'empilement.<br>
Ainsi il est possible de lancer le processus complet puis d'aller se coucher 
pour visualiser les premiers résultats après une bonne nuit (journée ?) de 
sommeil.</font></p>
<hr color="#0000FF">
<p align="justify"><b><font face="Arial" size="4" color="#FF0000">
<a name="Alignment"></a>Alignement</font></b><font face="Arial"><b><br>
<font size="2">Calcul des décalages et des angles de rotations</font><br>
</b><font size="2">Lors du processus d'alignement, l'image ayant obtenue le 
meilleur score est utilisée comme image de départ sauf si vous avez choisi une 
autre image comme image de référence en utilisant le
<a href="userguide.htm#contextmenu">menu contextuel</a>.<br>
Tous les décalages et rotations sont calculés en référence à cette image.<br>
<br>
Le calcul des décalages et de l'angle de rotation est effectué en identifiant 
les groupes d'étoiles dont les distances se retrouve d'une image sur l'autre.<br>
Pour faire simple, l'algorithme cherche les plus grands triangles pour lesquels 
les distances des cotés (et donc les angles entre les cotés) sont les plus 
proches.<br>
Lorsqu'un nombre suffisant de triangles ayant ces caractéristiques est détecté 
entre l'image de départ et l'image à aligner, le décalage et la rotation sont 
calculés et validés par la méthode des moindres carrés.<br>
En fonction du nombre d'étoiles une transformation bilinéaire ou bicarrée et 
utilisée.<br>
<br>
Pour plus d'information sur les algorithmes ayant inspirés celui utilisé par 
DeepSkyStacker vous pouvez consulter les 
informations suivantes (en anglais) :<br>
<a target="_blank" href="http://adsabs.harvard.edu/cgi-bin/nph-bib_query?bibcode=1995PASP..107.1119V&db_key=AST&high=39463d35aa24090">
FOCAS Automatic Catalog Matching Algorithms</a><br>
</font></font><font SIZE="2" face="Arial">
<a target="_blank" href="http://lear.inrialpes.fr/pubs/2004/MR04/">Pattern 
Matching with Differential Voting and Median Transformation Derivation</a></font></p>
<p align="justify"><font face="Arial" size="2"><b><a name="stackinfofile"></a>
Réutilisation automatique des décalages précédemment calculés<br>
</b>DeepSkyStacker enregistre toutes les transformation entre une image de 
référence et toutes les autres images de façon à ce qu'il ne soit pas nécessaire 
de les calculer de nouveau tant que les informations d'enregistrement n'ont pas 
été modifiées.<br>
Les informations sont enregistrées dans un fichier dont le nom est celui de 
l'image de référence (et dans le même répertoire) avec une extension<i> .stackinfo.txt</i>.</font></p>
<hr color="#0000FF">
<p align="justify"><font size="2" face="Arial"><a name="filegroup"></a></font><b><font face="Arial" size="4" color="#FF0000">Les groupes de fichiers<br>
</font></b><font size="2" face="Arial">Les groupes de 
fichiers permettent de simplifier la gestion de sessions sur un même objet 
réparties sur plusieurs nuits en regroupant logiquement  des fichiers d'une même 
session.<br>
<b>Si vous n'utilisez que le <i>groupe principal</i> DeepSkyStacker se comporte 
exactement comme avant.</b><br>
<br>
Il y a deux types de groupe : le <i>groupe principal</i> et les autres.</font></p>
<ul>
  <li>
  <p align="justify"><font size="2" face="Arial">Les fichiers images du <i>groupe principal</i> 
  ne peuvent être associés qu'à des darks, flats et offset/bias du <i>groupe 
  principal</i>. <br>
  Cela correspond au fonctionnement de DeepSkyStacker avant l'introduction des 
  groupes de fichiers.</font></li>
  <li>
  <p align="justify"><font size="2" face="Arial">Tous les fichiers darks, flats et offset/bias 
  du <i>groupe principal</i> peuvent être associés à des fichiers images de 
  n'importe quel groupe.</font></li>
  <li>
  <p align="justify"><font size="2" face="Arial">Tous les fichiers darks, flats et offset/bias 
  des autres groupes ne peuvent être associés qu'à des fichiers images du même 
  groupe.</font></li>
</ul>
<p align="justify"><font size="2" face="Arial">Vous pouvez créer autant de groupes que vous le 
souhaitez sachant qu'un fichier ne peut pas être présent dans deux groupes 
différents.</font></p>
<p align="justify"><font size="2" face="Arial"><b>Exemple d'utilisation :<br>
</b>Vous avez deux nuits d'affilée prit des photos d'un même objet. <br>
Pour chaque nuit vous avez un ensemble de photos, de darks et de flats, mais la 
température ayant variée d'une nuit à l'autre les darks ne sont pas compatibles 
d'une nuit sur l'autre et l'orientation ayant légèrement changée les flats sont 
également différents.<br>
<br>
Afin d'associer les bons darks et les bons flats avec les bonnes images il 
suffit de mettre toutes les photos+darks+flats de la première nuit dans un 
groupe et tous ceux de la seconde nuit dans un second groupe.<br>
Les offsets/bias étant communs à toutes les photos ceux ci doivent être mis dans 
le groupe principal.<br>
<br>
DeepSkyStacker associera automatiquement les photos de la première nuit avec 
darks et flats de la première nuit et les photos de la seconde nuit avec les 
darks et flats de la seconde nuit. Les offset/bias communs (puisque dans le <i>
groupe principal</i>) seront utilisés pour les photos de la première et de la 
seconde nuit.</font></p>
<hr color="#0000FF">
<p align="justify"><b><font face="Arial" size="4" color="#FF0000">
<a name="Stacking"></a>Empilement</font></b><font face="Arial"><b><br>
<font size="2"><a name="backgroundcalibration"></a>Calibration du fond des 
images</font><br>
</b><font size="2">La calibration du fond des images consiste à normaliser la 
valeur du fond de chaque image de la pile avant l'empilement.<br>
La valeur du fond est la valeur médiane de tous les pixels de l'image.</font></font></p>
<p align="justify"><font size="2" face="Arial">Deux options sont disponibles :</font></p>
<ul>
  <li>
<p align="justify"><font face="Arial" size="2">Avec l'option de <b>Calibration 
du fond de chacun des canaux</b> le fond de chaque canal est ajusté pour 
correspondre au fond du même canal de l'image de référence.</font></p>
  </li>
  <li>
<p align="justify"><font face="Arial" size="2">Avec l'option de <b>Calibration 
RVB du fond</b>, les trois canaux <font color="#FF0000">rouge</font>,
<font color="#008000">vert</font> et <font color="#0000FF">bleu</font> de chaque 
image sont normalisés à la même valeur de fond qui est le minimum des trois 
valeurs médianes (une par canal) calculées sur l'image de référence.</font></p>
  </li>
</ul>
<p align="justify"><font face="Arial" size="2">En particulier, il est très important de sélectionner 
une des ces options lors de 
l'utilisation des méthodes de Kappa-Sigma Clipping ou Médiane Kappa-Sigma 
Clipping pour éviter d'empiler des images dont les fonds n'ont pas la même 
valeur.</font></p>
<hr color="#0000FF" size="1">
<p align="justify"><font face="Arial"><font size="2">
<b><a name="flatcalibration"></a>Calibration automatique des flats</b></font><b><br>
</b><font size="2">L'objectif de la calibration automatique des flats est 
d'égaliser les différences de luminosité entre les différents flats avant de les 
combiner ensemble pour obtenir un maître flat.<br>
<br>
Le premier flat est utilisé comme référence. Les autres flats sont normalisés de 
façon à ce que la luminosité moyenne et l'intervalle dynamique soit les mêmes 
que ceux du premier flat.</font></font></p>
<hr color="#0000FF" size="1">
<p align="justify"><font face="Arial"><font size="2">
<b><a name="hotpixelsremoval"></a>Détection et suppression automatique des 
pixels chauds</b></font><b><br>
</b><font size="2">L'objectif de la détection automatique et de la suppression 
des pixels chaud est de remplacer ces pixels hors norme par une valeur calculée 
à partir des pixels voisins.<br>
<br>
Dans un premier temps ces pixels sont identifiés par l'analyse des darks (ou du 
master dark quand il est disponible). Tous les pixels dont la valeur est 
supérieure à [médiane] + 16 x [écart type] sont marqués comme pixels chauds.<br>
<br>
Pour chacun de ces pixels la valeur dans l'image calibrée (après soustraction 
des bias/offset et dark et division par le flat) est interpolée à partir des 
pixels voisins.</font></font></p>
<hr color="#0000FF" size="1">
<p align="justify"><font face="Arial"><font size="2">
<b><a name="badlinesdetection"></a>Détection et suppression automatique des 
mauvaise colonnes </b></font><b><br>
</b><font size="2">Sur certaines caméras CCD il peut apparaître des colonnes&nbsp; 
blanches créées par le blooming sur les pixels chauds ou noires (colonnes 
mortes).<br>
<br>
La détection et la suppression des mauvaises colonnes peut être utilisées dans 
ces cas.<br>
Elle détecte automatiquement les lignes verticales de 1 pixel de large qui sont 
soit saturées, soit noires et les traite comme s'il s'agissait de pixels chauds 
en interpolant les valeurs à partir des pixels voisins.</font></font></p>
<hr color="#0000FF" size="1">
<p align="justify"><font face="Arial"><font size="2">
<b><a name="darkentropy"></a>Soustraction des darks basé sur la réduction de 
l'entropie</b></font><b><br>
</b><font size="2">La soustraction des darks peut être optionnellement optimisée 
par la réduction de l'entropie de l'image obtenue après soustraction.<br>
L'idée ici est d'appliquer un coefficient multiplicateur entre 0 et 1 au dark 
afin que l'image obtenue après soustraction ait l'entropie la plus faible 
possible.<br>
En pratique cela permet d'utiliser des darks qui ne sont pas créés dans les 
conditions optimales (en particulier de température)..<br>
</font></font><font size="2" face="Arial"><br>
Pour plus d'information sur cette méthode pour pouvez vous reporter au document 
suivant (en anglais):<br>
<a target="_blank" href="http://www.cs.ubc.ca/~heidrich/Papers/PICS.01.pdf">
Entropy-Based Dark Frame Subtraction</a></font></p>
<hr color="#0000FF" size="1">
<p align="justify"><font face="Arial"><b>
Processus d'empilement<br>
</b><font size="2">Le processus d'empilement de DeepSkyStacker est très 
classique.<br>
<u><b>Etape 1 <br>
</b></u></font></font><font face="Arial" size="2">Création du master offset à 
partir de toutes les images marquées offset (selon la méthode sélectionnée).<br>
Si plus d'une image est marqué offset, un master offset est enregistré dans le 
fichier MasterOffset_ISOxxx.tif (format TIFF 8 16 ou 32 bits) dans le répertoire de la 
première image marquée offset. Ce fichier pourra être utilisé comme offset 
unique lors d'une prochaine utilisation.<br>
<br>
<b>Etape 2<br>
</b>Création du master dark à partir de toutes les images marquées.dark (selon 
la méthode sélectionnée). 
Le master d'offset est soustrait à chaque dark.<br>
Si plus d'une image est marqué dark, un master dark est enregistré dans le 
fichier MasterDark_ISOxxx_yyys.tif (format TIFF 8 16 ou 32 bits) dans le répertoire de la 
première image marquée dark. Ce fichier pourra être utilisé comme dark unique 
lors de la prochaine utilisation.<br>
<br>
Création du master dark flat à partir de toutes les images marquées.dark flat (selon 
la méthode sélectionnée). 
Le master d'offset est soustrait à chaque dark flat.<br>
Si plus d'une image est marqué dark flat, un master dark flat est enregistré dans le 
fichier MasterDarkFlat_ISOxxx_yyys.tif (format TIFF 8 16 ou 32 bits) dans le 
répertoire de la première image marquée dark flat. Ce fichier pourra être 
utilisé comme dark flat unique lors de la prochaine utilisation.<br>
<br>
<b>Etape 3<br>
</b>Création du master flat à partir de toutes les images marquées flat (selon 
la méthode sélectionnée). 
Les masters d'offset et dark flat sont soustrait de chaque flat. Le master flat est 
automatiquement normalisé.<br>
Si plus d'une image est marqué flat, un master flat est enregistré dans le 
fichier MasterFlat_ISOxxx.tif (format TIFF 8 16 ou 32 bits) dans le répertoire de la 
première image marquée flat. Ce fichier pourra être utilisé comme flat unique 
lors de la prochaine utilisation.<br>
<br>
<b>Etape 4<br>
</b>Calculs des décalages et rotations pour toutes les images à empiler.<br>
<br>
<b>Etape 5<br>
</b>Création de l'image finale par addition des images individuelles selon la 
méthode sélectionnée. <br>
Le 
master d'offset et le master de dark sont automatiquement soustrait de chaque image et le 
résultat est divisé par le master flat normalisé et si l'option est activée les 
pixels chauds détectées dans le master dark sont supprimés et remplacés par la 
valeur interpolée à partir des pixels voisins.<br>
<br>
<b>Etape 6<br>
</b>Dans le cas du développement raw avec la méthode du
<a href="#bayerdrizzle">Bayer drizzle</a>, les valeurs des trois composantes RGB 
sont normalisées pour éviter les trous d'information.<br>
<br>
<b>Etape 7<br>
</b>L'image résultant du traitement est automatiquement enregistrée dans 
un fichier AutoSave.tif qui est située dans le même répertoire que la 
première des images empilées.</font></p>
<hr color="#0000FF" size="1">
<p align="justify"><b>
<span lang="FR-FR" style="font-family: Arial"><a name="ChannelsAlignment"></a>
Alignement des canaux RVB<br>
</span></b><font size="2"><span style="font-family: Arial">Quand cette option 
est activée </span></font><span lang="FR-FR" style="font-size: 10.0pt; font-family: Arial">DeepSkyStacker </span>
<span style="font-size: 10.0pt; font-family: Arial">essayes d'aligner les trois 
canaux de l'image finale pour réduire le décalage des couleurs entre les canaux</span><span lang="FR-FR" style="font-size: 10.0pt; font-family: Arial">.<br>
</span><span style="font-size: 10.0pt; font-family: Arial">Le principal effet 
visible est que les étoiles ne sont plus rouge d'un coté et bleu de l'autre</span><span lang="FR-FR" style="font-size: 10.0pt; font-family: Arial">.<br>
<br>
</span><span style="font-size: 10.0pt; font-family: Arial">Chaque canal est 
enregistré (les étoiles sont détectées) et une transformation est calculée entre 
le meilleur canal et les deux autres</span><span lang="FR-FR" style="font-size: 10.0pt; font-family: Arial">.<br>
</span><span style="font-size: 10.0pt; font-family: Arial">La transformation est 
alors appliquée aux deux autres canaux ce qui a pour effet de les aligner sur le 
meilleur canal</span><span lang="FR-FR" style="font-size: 10.0pt; font-family: Arial">.</span></p>
<hr color="#0000FF" size="1">
<p align="justify"><b>
<span style="font-family: Arial"><a name="reusemasters"></a>Réutilisation 
automatique des fichiers maître précédemment créés<br>
</span></b><span style="font-size: 10.0pt; font-family: Arial">Les fichiers 
maître existants (dark, offset, flat et dark flat) créés depuis une liste de fichiers sont 
automatiquement utilisés quand c'est possible tant que :<br>
- La liste des fichiers utilisés pour les créer n'est pas modifiée.<br>
- Les paramètres utilisés pour les créer ne sont pas modifiés. Ceci inclus la 
méthode d'empilement et les paramètres de développement RAW ou FITS quand des 
fichiers RAW ou FITS sont utilisés.<br>
<br>
Un fichier texte contenant les paramètres et la liste des fichiers utilisés est 
enregistré dans le dossier du fichier maître correspondant.<br>
Le fichier de description a le même nom que le fichier maître avec l'extension .Description.txt.<br>
<br>
Lorsque la description ne correspond les nouveaux paramètres plus les fichiers 
maîtres sont automatiquement recréés.<br>
<br>
Cette fonctionnalité est complètement transparente pour l'utilisateur qui ne 
constate que le gain de temps lorsqu'il n'est pas nécessaire de recréer les 
fichiers maîtres.</span></p>
<hr color="#0000FF" size="1">
<p align="justify"><b><font face="Arial"><a name="customrect"></a>Utilisation 
d'un rectangle personnalisé</font></b><font face="Arial"><b><br>
</b><font size="2">DeepSkyStacker permet d'utiliser un rectangle personnalisé 
qui va définir la position et la taille de l'image résultante.<br>
<br>
Pour ce faire, vous devez d'abord visualiser une image en cliquant dessus depuis 
la liste. <br>
Vous pouvez choisir n'importe quelle image mais comme vous allez définir le 
rectangle qui va contenir l'image résultante, le mieux est de sélectionner 
l'image qui va servir de référence à l'empilement (celle dont le score est le 
plus important ou celle que vous avez choisie en forçant le choix via le
<a href="userguide.htm#contextmenu">menu contextuel</a>).<br>
<br>
Ensuite il suffit juste de sélectionner à la souris le rectangle que vous 
souhaitez utiliser comme rectangle personnalisé.<br>
Lorsque que vous lancerez l'empilement, le rectangle que vous avez sélectionné 
sera choisi par défaut comme méthode d'empilement.<br>
<br>
Cette option peut être particulièrement utile si vous utilisez l'option
<a href="#Drizzle">Drizzle</a> qui double ou triple la taille des images 
résultantes et donc l'espace disque et l'espace mémoire utilisés lors de 
l'empilement.<br>
<br>
En effet, lorsqu'un rectangle personnalisé plus petit est utilisé pour l'image 
résultante, DeepSkyStacker n'utilise que l'espace disque et la mémoire 
nécessaire pour créer une image de la taille du rectangle personnalisé.</font></font></p>
<hr color="#0000FF">
<p align="justify">
<b><font face="Arial" color="#FF0000"><a name="stackingmethods"></a>Les méthodes 
d'empilement</font><font face="Arial" size="2"><font color="#FF0000"><br>
</font>
<font color="#800000">Moyenne</font><br>
</font>
</b><font face="Arial" size="2">C'est la méthode la plus simple. La moyenne des valeurs des pixels de la 
pile est calculée pour chaque pixel. Aucun pixel n'est rejeté.<br>
<br>
<b><font color="#800000">Médiane</font><br>
</b>C'est la méthode par défaut pour la création des masters dark, flat et 
offset. La valeur médiane de la pile est calculée pour chaque pixel.<br>
<br>
<b><font color="#800000">Maximum</font><br>
</b>C'est une méthode ultra simple à n'utiliser qu'avec beaucoup de précaution. 
La valeur maximale des pixels de la pile est calculée pour chaque pixel.<br>
<br>
<b><font color="#800000">Kappa-Sigma Clipping</font><br>
</b>Cette méthode permet d'écarter les pixels déviants de façon itérative.<br>
Deux paramètres sont fixés : le nombre d'itération et la coefficient 
multiplicateur de l'écart type utilisée (Kappa).<br>
A chaque itération, la moyenne et l'écart type (Sigma) des pixels de la pile 
sont calculés.<br>
Tout pixel dont la valeur s'écarte de la moyenne de plus de Kappa * Sigma est 
rejeté.<br>
La moyenne des pixels restant est calculée pour chaque pixel.<br>
<b><font color="#800000"><br>
Kappa-Sigma Clipping Médiane</font><br>
</b>Cette méthode est similaire à la méthode Kappa-Sigma Clipping mais au lieu 
de rejeter les valeurs elles sont remplacées par la médiane.<br>
<br>
<font color="#800000"><b>Moyenne pondérée auto adaptative</b></font><br>
La moyenne pondérée auto adaptative est adaptée des travaux de Stetson (<a target="_blank" href="http://archive.eso.org/archive/hst/wfpc2_asn/3sites/WFPC2_Newsletter.pdf">voir 
Artificial Skepticism - Stetson 1989</a>).<br>
Cette méthode permet de calculer une moyenne robuste obtenue en pondérant de 
façon itérative les pixels en fonction de leurs écart à la moyenne par rapport à 
l'écart moyen.<br>
<br>
<font color="#800000"><b>Moyenne pondérée par l'entropie (High Dynamic Range)</b></font><br>
Cette méthode est basée sur les travaux de German, Jenkin et Lesperance (<a target="_blank" href="http://doi.ieeecomputersociety.org/10.1109/CRV.2005.38">Entropy-Based 
image merging - 2005</a>) et permet d'additionner les images en conservant la 
meilleure dynamique de chaque image, pixel par pixel.<br>
Elle permet en particulier de lors de l'addition d'image réalisées avec des 
sensibilités et des temps de pause différent de conserver la meilleure dynamique 
possible sur l'image finale. En clair cela permet d'éviter de brûler le centre 
des galaxies et nébuleuses.<br>
Note : cette méthode est particulièrement consommatrice en temps machine et en 
mémoire.</font></p>
  <span>
  <hr size="2" width="100%" noshade color="blue" align="center">
<p align="justify"><b><font face="Arial" size="4" color="#FF0000">
<a name="Drizzle"></a>Drizzle</font></b><br>
<font face="Arial" size="2">Le Drizzle est une méthode développée par la NASA 
pour les observations du projet Hubble Deep Field réalisées par le Télescope 
Spatial Hubble.<br>
L'algorithme est aussi connu sous le nom de Variable Pixel Linear Reconstruction.<br>
<br>
Il a de nombreux usages dont celui de pouvoir améliorer la résolution d'une pile 
d'image par rapport à la résolution d'une seule image tout en préservant les 
caractéristiques de l'image (couleurs, luminance).</font></p>
<table border="0" cellspacing="1" width="100%" id="AutoNumber4">
  <tr>
    <td width="40%" valign="top">
    <p class="Standard">
  <span>
    <font face="Arial" size="2">Pour faire simple chaque image est agrandie 2 ou 
  3 fois juste avant d'être empilée (n'importe quelle valeur supérieure à 1 peut 
  être utilisée mais DeepSkyStacker propose uniquement des facteurs 2 ou 3 qui 
  sont des valeurs classiques), puis projetée sur une grille plus grande.<br>
    <br>
    Le résultat est que la taille de l'image finale est doublée (ou triplée) et 
  qu'un petit objet qui n'occupait qu'une dizaine de pixels va maintenant en 
  occuper deux ou trois fois plus ce qui va simplifier le post traitement.</font></span></td>
    <td width="60%">
    <p align="center">
    <img border="0" src="../images/Drizzle.jpg" align="center" width="250" height="250"></td>
  </tr>
  <tr>
    <td width="40%" valign="top">
    <p class="Standard"><font face="Arial" size="2">
  <span>
    <b>Quand et de quoi avez vous besoin pour utiliser l'option Drizzle</b><br>
    Juste d'un nombre important d'images qui ne soient pas parfaitement alignées 
    (un décalage de quelques pixels suffit).<br>
    Cela n'a pas de sens d'utiliser le drizzle avec seulement quelques images brutes.<br>
    <br>
    Le Drizzle est particulièrement efficace pour améliorer la résolution et 
    donc il est particulièrement utile lorsque  de petits objets sont 
    photographiés avec une courte focale.<br>
    <br>
    L'exemple ci contre montre un exemple de M57 à peine post traitée (photo 
    prise avec un télescope de 254/1200 et un appareil photo Canon).<br>
    <br>
    D'habitude M57 est très petite dans cette configuration mais en utilisant un 
    Drizzle x2 et environ 100 images brutes, l'image résultante est deux fois 
    plus grande et la résolution est bien meilleure.<br>
    <br>
    Passer la souris sur le texte pour voir<br>
&nbsp;&nbsp; <a onmouseover="document['DRIZZLE01'].src='../images/M57_NoDrizzle.jpg';;document.getElementById('DRIZZLELEGEND01').innerHTML='M57 - Pas de Drizzle - Agrandie 4 fois';" href="javascript:void(0);">
M57 non traitée - Pas de Drizzle (agrandie 4 fois)</a><br>
&nbsp;&nbsp; <a onmouseover="document['DRIZZLE01'].src='../images/M57_Drizzle.jpg';;document.getElementById('DRIZZLELEGEND01').innerHTML='M57 - Drizzle x2 - Agrandie 2 fois';" href="javascript:void(0);">
M57 non traitée - Drizzle x2 (agrandie 2 fois)</a></span></font></td>
    <td width="60%">
    <p align="center">
    <img id="DRIZZLE01" name="DRIZZLE01" border="0" src="../images/M57_NoDrizzle.jpg" width="411" height="353"><br>
    <font face="Arial" size="2"><b id="DRIZZLELEGEND01" name="DRIZZLELEGEND01">M57 - 
    Pas de Drizzle (Agrandie 4 fois)</b></font></td>
  </tr>
</table>
<p align="justify"><b><font face="Arial" size="2">Les effets secondaires de 
l'utilisation du drizzle</font></b><font face="Arial" size="2"><br>
Le principal effet secondaire est que la quantité de mémoire et d'espace disque 
nécessaire pour créer et traiter les images est multipliée par le carré du 
facteur de drizzle. Bien entendu le temps de traitement pour créer les images 
est également allongé.<br>
<br>
Par exemple, en utilisant le Drizzle x2 sur une image de 3000x2000 pixels, 
l'image résultante fera 6000x4000 pixels et va nécessiter 4 fois la quantité de 
mémoire et d'espace disque et va être beaucoup plus longue a créer.<br>
<br>
Lorsque le Drizzle x3 est utilisée, tout est multiplié par 9 (3 au carré) et 
sauf si vous avez une machine très puissante et beaucoup de mémoire et d'espace 
disque disponible vous ne souhaitez pas l'utiliser à partir d'images créées par 
des APN.<br>
<br>
Toutefois sur des petites images (telles que celles créées par les premières 
caméras DSI et LPI) cela peut être utile d'utiliser un Drizzle x3 pour augmenter 
la résolution de l'image finale.<br>
<br>
Dans tous les cas une bonne façon de limiter l'augmentation de la quantité 
d'espace disque et de mémoire nécessaire liés au Drizzle est d'utiliser un
<a href="#customrect">rectangle personnalisé</a>.<br>
<br>
<b>Drizzle et Bayer Drizzle</b><br>
Même s'ils utilisent deux versions de l'algorithme Drizzle, il n'est pas 
recommandé d'utiliser le Drizzle et le Bayer Drizzle en même temps.<br>
DeepSkyStacker affiche un avertissement quand vous essayez de le faire.</font></p>
  </span>
  <span>
  <hr size="2" width="100%" noshade color="blue" align="center">
<p align="justify"><b><font face="Arial" size="4" color="#FF0000">
<a name="cometstacking"></a>Empilement d'images de comète</font></b><br>
<font face="Arial" size="2">Les comètes sont des objets se déplaçant rapidement 
et lorsque des images de comètes sont empilées deux choses peuvent arriver :<br>
- si l'alignement est réalisé sur les étoiles la comète est floue<br>
- si l'alignement est réalisé sur la comète les étoiles ne sont pas ponctuelles.<br>
<br>
A partir de la version 3.0 DeepSkyStacker ajoute deux options spécifiques à 
l'empilement d'image de comète:<br>
- Créer une image alignée sur la comète qui va montrer des filés d'étoiles<br>
- Créer une image alignée sur la comète et sur les étoiles qui ne montrera pas 
de filés d'étoiles.<br>
<br>
Ci dessous un exemple des différents modes d'empilement (passer la souris sur le 
texte pour voir les résultats)</font></p>
<table border="0" cellspacing="1" width="100%" id="AutoNumber5">
  <tr>
    <td width="41%">
<p style="margin-left: 10; margin-right: 10"><font face="Arial" size="2"><br>
<b><a onmouseover="document['COMETSTACK'].src='../images/FuzzyComet.jpg';" href="javascript:void(0);">
Empilement standard</a></b><br>
La position de la comète est ignorée.<br>
La comète est floue est les étoiles sont ponctuelles.</font></p>
<p style="margin-left: 10; margin-right: 10"><a href="javascript:void(0);"><b>
<font face="Arial" size="2"><a onmouseover="document['COMETSTACK'].src='../images/StarTrails.jpg';" href="javascript:void(0);">
Alignement sur la comète : filés d'étoiles</font></b></a><font face="Arial" size="2"><br>
La position de la comète est utilisée. Les images sont alignées sur la comète et 
les positions des étoiles sont utilisées uniquement pour compenser une rotation 
du champ.<br>
<br>
<b><a onmouseover="document['COMETSTACK'].src='../images/StarFreeze.jpg';" href="javascript:void(0);">
Alignement sur la comète et les étoiles : effet &quot;étoiles arrêtées&quot;</a></b><br>
La position de la comète est utilisée.<br>
Un premier empilement est réalisé pour extraire la comète du fond stellaire.<br>
Ensuite un second empilement est réalisé pour geler les étoiles (la comète est 
soustraite de chaque image calibrée et enregistrée avant l'empilement).<br>
Pour finir l'image finale est obtenue en insérant la comète de nouveau dans 
l'image ainsi obtenue.</font></p>
<p style="margin-left: 10; margin-right: 10">&nbsp;</p>
    </td>
    <td width="59%" align="center">
    <img name = "COMETSTACK" id = "COMETSTACK" border="0" src="../images/FuzzyComet.jpg" width="472" height="366"></td>
  </tr>
</table>
<p align="justify"><font face="Arial" size="2">&nbsp;<br>
Si vous prévoyez d'aligner uniquement sur les étoiles vous n'avez pas besoin de 
faire ce qui est décrit dans les paragraphes ci dessous puisqu'il s'agit du 
comportement par défaut.<br>
<br>
</font><font face="Arial"><b><font size="2">Ce que vous devez faire <br>
Etape 1 : Enregistrer la position de la comète</font><br>
</b></font><font face="Arial" size="2">DeepSkyStacker ne peut pas détecter 
automatiquement la position de la comète dans les images brutes.<br>
<br>
Premièrement vous devez préciser la position de la comète <b>dans chacune des 
images brutes</b>. Ceci ne doit être fait qu'une seule fois.</font></p>
<p align="justify"><font face="Arial" size="2">Pour ce faire, sélectionnez juste une image brute dans la liste et en utilisant 
le <a href="userguide.htm#imagepreview">mode d'édition de la comète</a> précisez 
la position de la comète dans l'image.<br>
Si le centre de la comète est trop faible ou trop brillant vous devrez forcer 
DeepSkyStacker à accepter n'importe quelle position en maintenant la touche 
majuscule enfoncée pendant que vous positionnez le centre de la comète.<br>
<br>
Ensuite vous devez enregistrer le résultat en cliquant sur le bouton Enregistrer 
les modifications de la barre d'outils.<br>
Si vous ne le faite pas DeepSkyStacker vous le demandera et vous aurez une 
option pour enregistrer les modifications automatiquement.<br>
<br>
Une fois que la position de la comète est fixée vous verrez apparaître un +(C) à 
coté du nombre d'étoiles dans la colonne #Etoiles de la liste.<br>
<br>
Vous devez répéter cette opération pour toutes les images brutes. </font></p>
<table border="1" cellspacing="1" width="100%" id="AutoNumber6" cellpadding="10">
  <tr>
    <td width="100%" bgcolor="#FFFF99"><font face="Arial" size="2">
  <span>
    <b>Astuce<br>
    </b>
  <span lang="FR-FR">
  Si la date et l'heure des images est précise (comme en utilisant un APN ou 
certaine</span>s<span lang="FR-FR">
    caméra</span>s<span lang="FR-FR">
  
  CCD) vous pouvez trier les images sur la date et l'heure et 
fixer la position de la comète uniquement sur la première et la dernière image 
ainsi que sur l'image de référence (celle qui a le score le plus important si 
vous n'avez pas utilisé le menu contextuel pour forcer une autre image de 
référence). <br>
DeepSkyStacker calculera 
</span>
    alors automatiquement (juste avant l'empilement) la position du centre de la 
    comète dans toutes les images dans l'intervalle de temps pour lesquelles la 
    position n'est pas fixée. <br>
    Pour ce faire il utilisera le temps écoulé entre la première image et chaque 
    image pour interpoler la position de la comète.</span></font></td>
  </tr>
</table>
<p align="justify"><font face="Arial"><b><font size="2">Etape 2 : Sélectionner le mode 
d'empilement</font><br>
</b></font><font face="Arial" size="2">Ceci est réalisé dans l'<a href="userguide.htm#comettab">onglet 
Comète</a> du dialogue des paramètres d'empilement.<br>
Cet onglet est disponible dès que au moins deux images (y compris l'image de 
référence) ont une comète enregistrée.<br>
Depuis cet onglet vous pouvez sélectionner l'un des trois modes d'empilement 
disponibles pour les comètes.<br>
&nbsp;<br>
<b>Mélanger des images contenant une comète avec des images ne contenant pas de 
comète</b><br>
DeepSkyStacker peut utiliser des images contenant et ne contenant pas une comète 
enregistrée dans la même pile.<br>
Ceci peut être très utile pour obtenir un meilleur rapport signal/bruit sur 
l'image résultante en particulier pour faire ressortir les détails faibles du 
fond stellaire (une comète passant à coté d'une nébuleuse ou d'une galaxie par 
exemple).</font></p>
<p align="justify"><font face="Arial" size="2"><b>Quel mode d'empilement<br>
</b>Si vous cherchez à faire des filés d'étoiles la moyenne est la meilleure 
méthode.<br>
Dans les autres cas il est préférable d'utiliser un empilement médian pour peu 
d'images et kappa-sigma lorsque beaucoup d'images sont disponibles.</font></p>
<p align="justify"><font face="Arial" size="2"><b>Quels résultats espérer</b><br>
De toute évidence l'algorithme le plus exigeant est celui qui permet d'obtenir 
l'effet &quot;étoiles arrêtées&quot;.<br>
Des comètes se déplaçant peu rendent complexe la détection des gros objets ou 
étoiles très brillantes du fond stellaire et dans ce cas l'extraction de la 
comète peut ne pas être parfaite.<br>
Dans tous les cas, si vous prenez des images de la même zone sans la comète (la 
veille ou le lendemain) cela améliorera la qualité de l'image finale.</font></p>
  </span>
<hr color="#0000FF">
<p align="justify"><font face="Arial"><b><font size="4" color="#FF0000"><a name="rawdecod"></a>Décodage et traitement 
des fichiers raw</font><br>
<font size="2">Décodage des fichiers raw</font><br>
</b><font size="2">Les fichiers raw produits par les appareils photos numériques 
sont décodés à l'aide de
<a target="_blank" href="http://www.cybercom.net/~dcoffin/dcraw/">DCRAW</a> de 
Dave Coffin.<br>
La liste des appareils photos supportées est très longue et est constamment mise 
à jour par Dave Coffin. DeepSkyStacker intègre la dernière version de DCRAW et 
est (et sera) mis à jour régulièrement en fonction des mises à jour de DCRAW.</font></font></p>

<hr color="#0000FF">
<p align="justify"><font face="Arial"><b>
<font size="2">Le développement des fichiers raw</font><br>
</b><font size="2">Un fichier raw peut être comparé à un négatif numérique. 
Chaque fichier raw nécessite donc un processus de développement..<br>
Il est possible de distinguer deux types de fichiers raw : ceux qui sont basés 
sur une matrice de Bayer (l'écrasante majorité), et ceux qui ne le sont pas (en 
particulier ceux qui utilisent des capteurs Foveon).<br>
<br>
Je ne m'intéresserais dans la suite qu'aux fichiers raw basés sur une matrice de 
Bayer.</font></font></p>

<hr color="#0000FF">
<p align="justify"><font size="2" face="Arial"><b>Utilisation de la matrice de Bayer<br>
</b>Tout d'abord un petit rappel sur la matrice de Bayer.<br>
Prenons le cas d'un appareil photo numérique 8 millions de pixels. Le capteur 
CCD ou CMOS de cet appareil photo est en fait un capteur noir et blanc de 8 
millions de pixels sur lequel est plaquée la fameuse matrice de Bayer qui 
consiste en une succession de filtres RGBG ou CYMK (il y a également d'autres 
variantes).<br>
<br>
Dans le cas des filtres RGBG un quart des des pixels capte le
<font color="#FF0000">rouge</font>, un autre quart le <font color="#0000FF">bleu</font> 
et la moitié restante le <font color="#008000">vert</font>.<br>
En fait votre appareil photo 8 millions de pixels contient donc 2 millions de 
pixels pour le rouge, autant pour le bleu, et 4 millions de pixels pour le vert.<br>
<br>
Alors comment sont reconstituées les &quot;vraies&quot; couleurs par l'appareil photo ?<br>
Tout simplement en interpolant les couleurs primaires manquantes à partir des 
pixels alentour. </font></p>

<hr color="#0000FF">
<p><font size="2" face="Arial"><b>Reconstitution des couleurs à partir de la 
matrice de Bayer- <font color="#0000FF">L'interpolation</font></b></font></p>

<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="87%" id="AutoNumber1">
  <tr>
    <td width="51%">
    <p class="Standard"><font size="2" face="Arial">La première méthode permettant 
    de reconstituer les couleurs à partir de la matrice de Bayer consiste donc à 
    interpoler les couleurs manquantes à partir des pixels avoisinants.</font></p>
    <p class="Standard">
    <font size="2" face="Arial"><br>
    De nombreuses méthodes d'interpolation permettent d'obtenir des résultats 
    plus ou moins bons (linéaire, gradient ...), mais toute au détriment de la 
    qualité de l'image finale par rapport au négatif numérique. En effet, qui 
    dit interpolation dit &quot;estimation&quot; et donc l'introduction d'une imprécision 
    dans l'image traitée et a fortiori dans l'image finale qui est la somme des 
    images empilées.<br>
    <br>
    A ce propos, les logiciels fournis avec les appareils photos numériques sont 
    probablement les moins bien placés en terme de qualité dans le cadre d'une 
    utilisation en astrophotographie. <br>
    Si vous les utilisiez pour transformer vos fichiers RAW en fichiers TIFF 16 
    bits, vous pourrez constater immédiatement une amélioration sensible en 
    utilisant DeepSkyStacker.<br>
&nbsp;</font></td>
    <td width="51%">
    <img border="0" src="../images/BayerInterpolation.jpg" width="375" height="285" align="right"></td>
  </tr>
</table>
<hr color="#0000FF">
<p><font size="2" face="Arial"><b><a name="superpixel"></a>Reconstitution des couleurs à partir de la 
matrice de Bayer- <font color="#0000FF">Le super-pixel</font></b></font></p>

<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="87%" id="AutoNumber2">
  <tr>
    <td width="51%">
    <p class="Standard"><font face="Arial" size="2">Grâce à DCRaw il est possible 
    d'accéder directement à la matrice de Bayer avant toute interpolation. ceci 
    permet d'utiliser d'autres méthodes pour reconstituer les vraies couleurs 
    sans &quot;estimer&quot; les valeurs manquantes par interpolation.</font></p>
    <p class="Standard">
    <font size="2" face="Arial">La seconde méthode consiste à éviter 
    l'interpolation en créant un seul super pixel à partir de chaque groupe de 4 
    pixels (RGBG).</font></p>
    <p class="Standard"><font size="2" face="Arial"><br>
    En effet tous les groupes de 4 pixels contiennent l'intégralité de 
    l'information pour chacune des couleurs primaires et pour la luminance.<br>
    Cette méthode à l'avantage de la simplicité et l'inconvénient (ou est-ce un 
    avantage ?) de diviser la taille des images résultantes par 4.<br>
    <br>
    La méthode du super-pixel donne de très bon résultats dans le cas où peu 
    d'images sont disponibles.</font></td>
    <td width="49%">
    <img border="0" src="../images/BayerSuperPixel.jpg" align="right" width="373" height="280"></td>
  </tr>
</table>
<p>&nbsp;</p>

<hr color="#0000FF">
<p><font size="2" face="Arial"><b><a name="bayerdrizzle"></a>Reconstitution des 
couleurs à partir de la matrice de Bayer- <font color="#0000FF">Le Bayer drizzle</font></b></font></p>

<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="87%" id="AutoNumber3">
  <tr>
    <td width="51%">
    <p class="Standard"><font size="2" face="Arial">La .dernière méthode, qui m'a 
    été suggérée par Dave Coffin,  utilise la spécificité de 
    l'empilement des images astro pour calculer les vraies valeurs RGB de chaque 
    pixel en profitant du décalage &quot;naturel&quot; qui existe entre chaque photo.<br>
    <br>
    Lorsque qu'un nombre relativement important d'images est disponible, et en 
    profitant d'un alignement avec une précision supérieure au pixel, 
    DeepSkyStacker détermine ainsi par petit bout les valeurs réelles des trois 
    composantes RGB pour chaque pixel, et ce sans qu'aucune interpolation ne 
    soit nécessaire.<br>
&nbsp;<br>
    A l'issue du processus d'empilement, un algorithme est utilisé pour 
    normaliser les valeurs des trois composantes RGB et ainsi éviter les &quot;trous&quot; 
    d'information.<br>
    <br>
    Cette méthode donne d'excellent résultats lorsqu'un nombre important 
    d'images est disponible et lorsque la précision du suivi ou de l'autoguidage 
    est inférieure au pixel (ce qui est quasiment tout le temps le cas).</font></td>
    <td width="49%">
    <img border="0" src="../images/BayerDrizzle.jpg" width="375" height="287" align="right"></td>
  </tr>
</table>
<p>&nbsp;</p>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-7477345-1");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>

</html>